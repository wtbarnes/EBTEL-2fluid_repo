{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ebtel++ ebtel++ is a two-fluid version of the original enthalpy-based thermal evolution of loops (EBTEL) model implemented in C++. This code provides an enhanced description of plasma behavior above roughly 5 MK. Further generic details about EBTEL can be found in the repository for the original IDL code and in the references listed below. The EBTEL model, originally developed by Klimchuk et al. (2008) efficiently computes spatially-averaged, time-dependent plasma parameters ( e.g. temperature, pressure, density) of dynamically-heated coronal loops. It is often desirable to compute solutions for a large number of coronal loops, but the spatial and temporal scales needed to solve the full 1D-hydrodynamic equations lead to long compute times for even 1D hydrodynamic codes. EBTEL computes quick and accurate solutions for spatially-averaged quantities, allowing efficient insight into how these monolithic structures evolve. Barnes et al. (2016) improved upon this model by extending the treatment to the two-fluid hydrodynamic equations, allowing for differential heating between electrons and ions. Experienced EBTEL users should note the slightly different model for calculating the the c1 parameter during conductive cooling (see Appendix A of Barnes et al., 2016 ). EBTEL also calculates the differential emission measure (DEM) for both the transition region and the corona. Details regarding this formulation can be found in Klimchuk et al. (2008) Citation If you use ebtel++ in any published work, please include the following citations and mention the use of this code. Klimchuk et al. (2008) Cargill et al. (2012a) Cargill et al. (2012b) Barnes et al. (2016) The first three papers detail the original single-fluid EBTEL model while the last paper gives the details of the two-fluid model. In particular, the details of how the two-fluid EBTEL equations are derived can be found in the appendix of Barnes et al. (2016) . Dependencies To compile ebtel++, first install the following dependencies, gcc (at least v4.7; included with OS X, most Linux distros; cygwin on Windows) scons ( pip install scons via PyPI or conda install scons with Anaconda ) boost (at least v1.53; sudo apt-get install libboost-dev on Debian Linux, sudo port install boost via Macports on OS X, from source on Windows; can also be installed via Anaconda ) Additionally, if you'd like to run the included tests and examples, you'll need the following Python dependencies, all easily installed with anaconda , Python numpy matplotlib seaborn Installation To download the code from GitHub and compile the code, $ git clone --recursive https://github.com/rice-solar-physics/ebtelPlusPlus.git $ cd ebtelPlusPlus $ scons If the compile step fails because the compiler cannot find the appropriate headers and/or libraries using the default locations, you can use the --includepath and/or --libpath flags, respectively. For example, if you've installed the Boost headers and libraries in /usr/local/include and /usr/local/lib , $ scons --includepath = /usr/local/include --libpath = /usr/local/lib For more information about the available flags that can be passed to scons , you can run scons -h . This will create an executable bin/ebtel++.run . To see the available command line parameters, $ bin/ebtel++.run --help and to run the executable with the default configuration file config/ebtel.example.cfg.xml , $ bin/ebtel++.run If you've installed the above Python dependencies, you can also run the tests using, $ scons --test or run any of the three included examples, $ python examples/ex1.py $ python examples/ex2.py $ python examples/ex3.py","title":"Getting Started"},{"location":"#ebtel","text":"ebtel++ is a two-fluid version of the original enthalpy-based thermal evolution of loops (EBTEL) model implemented in C++. This code provides an enhanced description of plasma behavior above roughly 5 MK. Further generic details about EBTEL can be found in the repository for the original IDL code and in the references listed below. The EBTEL model, originally developed by Klimchuk et al. (2008) efficiently computes spatially-averaged, time-dependent plasma parameters ( e.g. temperature, pressure, density) of dynamically-heated coronal loops. It is often desirable to compute solutions for a large number of coronal loops, but the spatial and temporal scales needed to solve the full 1D-hydrodynamic equations lead to long compute times for even 1D hydrodynamic codes. EBTEL computes quick and accurate solutions for spatially-averaged quantities, allowing efficient insight into how these monolithic structures evolve. Barnes et al. (2016) improved upon this model by extending the treatment to the two-fluid hydrodynamic equations, allowing for differential heating between electrons and ions. Experienced EBTEL users should note the slightly different model for calculating the the c1 parameter during conductive cooling (see Appendix A of Barnes et al., 2016 ). EBTEL also calculates the differential emission measure (DEM) for both the transition region and the corona. Details regarding this formulation can be found in Klimchuk et al. (2008)","title":"ebtel++"},{"location":"#citation","text":"If you use ebtel++ in any published work, please include the following citations and mention the use of this code. Klimchuk et al. (2008) Cargill et al. (2012a) Cargill et al. (2012b) Barnes et al. (2016) The first three papers detail the original single-fluid EBTEL model while the last paper gives the details of the two-fluid model. In particular, the details of how the two-fluid EBTEL equations are derived can be found in the appendix of Barnes et al. (2016) .","title":"Citation"},{"location":"#dependencies","text":"To compile ebtel++, first install the following dependencies, gcc (at least v4.7; included with OS X, most Linux distros; cygwin on Windows) scons ( pip install scons via PyPI or conda install scons with Anaconda ) boost (at least v1.53; sudo apt-get install libboost-dev on Debian Linux, sudo port install boost via Macports on OS X, from source on Windows; can also be installed via Anaconda ) Additionally, if you'd like to run the included tests and examples, you'll need the following Python dependencies, all easily installed with anaconda , Python numpy matplotlib seaborn","title":"Dependencies"},{"location":"#installation","text":"To download the code from GitHub and compile the code, $ git clone --recursive https://github.com/rice-solar-physics/ebtelPlusPlus.git $ cd ebtelPlusPlus $ scons If the compile step fails because the compiler cannot find the appropriate headers and/or libraries using the default locations, you can use the --includepath and/or --libpath flags, respectively. For example, if you've installed the Boost headers and libraries in /usr/local/include and /usr/local/lib , $ scons --includepath = /usr/local/include --libpath = /usr/local/lib For more information about the available flags that can be passed to scons , you can run scons -h . This will create an executable bin/ebtel++.run . To see the available command line parameters, $ bin/ebtel++.run --help and to run the executable with the default configuration file config/ebtel.example.cfg.xml , $ bin/ebtel++.run If you've installed the above Python dependencies, you can also run the tests using, $ scons --test or run any of the three included examples, $ python examples/ex1.py $ python examples/ex2.py $ python examples/ex3.py","title":"Installation"},{"location":"configuration/","text":"An ebtel++ run is configured by a single XML configuration file. The table below lists all of the input parameters needed for a run. An example configuration file is included in the GitHub repository. The configuration file can be written manually or configured via Python as is done in the included examples . Parameter Type Description total_time float duration of the simulation (in s) tau float timestep (in s); if using adaptive solver, the initial timestep tau_max float maximum allowed timestep (in s) when using adaptive solver loop_length float Loop half-length (in cm) saturation_limit float Flux limiter, f f in section 2.1 of Barnes et al. (2016) force_single_fluid bool if True, electron and ion populations forced into equilibrium use_c1_loss_correction bool use correction in Eq. 16 of Cargill et al. (2012a) use_c1_grav_correction bool use correction in Eq. 12 of Cargill et al. (2012a) use_flux_limiting bool impose a flux limiter according to Eq. 22 of Klimchuk et al. (2008) calculate_dem bool if True, do the TR and coronal DEM calculation; increases compute time significantly save_terms bool if True, save heat flux, c_1 c_1 parameter, and radiative loss to a separate file <output_filename>.terms use_adaptive_solver bool if True, use adaptive timestep; significantly smaller compute times. In both cases, a Runge-Kutta Cash-Karp integration method is used (see section 16.2 of Press et al. (1992) ) output_filename string path to output file adaptive_solver_error float Allowed truncation error in adaptive timestep routine adaptive_solver_safety float Refinement factor, between 0 and 1, used if timestep becomes too large and solution contains NaNs. Especially important for short, infrequently heated loops. Also controls decreases in timestep due to thermal conduction timestep. Suggested value is 0.5 c1_cond0 float Nominal value of c_1 c_1 during the conduction phase; see Appendix A of Barnes et al. (2016) c1_rad0 float Nominal value of c_1 c_1 during radiative phase; see Eq. 16 of Cargill et al. (2012a) helium_to_hydrogen_ratio float Ratio of helium to hydrogen abundance; used in correction to ion mass, ion equation of state surface_gravity float Surface gravity in units of solar surface gravity; should be set to 1.0 unless using for extra-solar cases Heating The time dependent heating is configured in a separate node. It includes the following parameters, Parameter Type Description partition float partition of heating between electrons and ions, between 0 and 1; 1 is pure electron heating, 0 pure ion heating background float constant background heating (in ergs cm ^{-3} ^{-3} s ^{-1} ^{-1} ) The heating function is constructed by a list of discrete events and should be specified in the following way, <events> <event magnitude= \"0.1\" rise_start= \"0.0\" rise_end= \"50.0\" decay_start= \"50.0\" decay_end= \"100.0\" /> <event magnitude= \"0.05\" rise_start= \"1000.0\" rise_end= \"1250.0\" decay_start= \"1350.0\" decay_end= \"1450.0\" /> </events> Here, we've configured two separate heating events. The first starts at 0 seconds, rises linearly to a maximum heating rate of 0.1 erg cm ^{-3} ^{-3} s ^{-1} ^{-1} in 50 seconds, and then immediately falls off with the event concluding at 100 seconds, i.e. a triangular heating profile. The second starts at 1000 seconds, rises to a maximum heating rate of 0.05 erg cm ^{-3} ^{-3} s ^{-1} ^{-1} in 250 seconds, is sustained at 0.05 for 100 seconds and then the event concludes at 1450 seconds. Using this format, it is easy to specify either symmetric or asymmetric events of many different shapes. For more examples, see the example configuration file or the included examples . Differential Emission Measure Optionally, ebtel++ can can also calculate the differential emission measure (DEM) in both the transition region and the corona. See sections 2.2 and 3 of Klimchuk et al. (2008) for the details of this calculation. To enable this calculation, set calculate_dem to True in the configuration file (as described above). Note that this will result in much longer computation times. If calculate_dem is set to True , ebtel++ will read in the dem node from the configuration file which should be structured as follows, <dem> <use_new_method> True </use_new_method> <temperature bins= \"451\" log_min= \"4\" log_max= \"8.5\" /> </dem> If use_new_method is set to True (False), the transition region DEM is calculated using the method outlined in section 3 (the appendix) of Klimchuk et al. (2008) . The temperature node configures the range and number of bins used when calculating the DEM. Here, for example, there are 450 bins of equal width between 10^4 10^4 and 10^{8.5} 10^{8.5} K. If you do not need to calculate the DEM, set the calculate_dem parameter to False and this section of the configuration file need not be included. Output Once the EBTEL run has finished, the results are printed to the file specified in output_filename in the configuration file (as described above). Several examples of how to parse the results in Python can be found here . In general, the results file follows the structure, t_0 t_0 T_e(t_0) T_e(t_0) T_i(t_0) T_i(t_0) n(t_0) n(t_0) p_e(t_0) p_e(t_0) p_i(t_0) p_i(t_0) v(t_0) v(t_0) h(t_0) h(t_0) ... ... ... ... ... ... ... ... t_i t_i T_e(t_i) T_e(t_i) T_i(t_i) T_i(t_i) n(t_i) n(t_i) p_e(t_i) p_e(t_i) p_i(t_i) p_i(t_i) v(t_i) v(t_i) h(t_i) h(t_i) ... ... ... ... ... ... ... ... t_{N-1} t_{N-1} T_e(t_{N-1}) T_e(t_{N-1}) T_i(t_{N-1}) T_i(t_{N-1}) n(t_{N-1}) n(t_{N-1}) p_e(t_{N-1}) p_e(t_{N-1}) p_i(t_{N-1}) p_i(t_{N-1}) v(t_{N-1}) v(t_{N-1}) h(t_{N-1}) h(t_{N-1}) Here t t is the time, T_e T_e is the electron temperature, T_i T_i is the ion temperature, p_e p_e is the electron pressure, p_i p_i is the ion pressure, n n is the density, v v is the velocity, and h h is the heating rate. If calculate_dem is set to True, the TR and coronal DEM results are printed to <output_filename>.dem_tr and <output_filename>.dem_corona , respectively. These output files are structured in the following way, T_0 T_0 ... T_j T_j ... T_{M-1} T_{M-1} DEM (t_0,T_0) (t_0,T_0) ... DEM (t_0,T_j) (t_0,T_j) ... DEM (t_0,T_{M-1}) (t_0,T_{M-1}) ... ... ... ... ... DEM (t_i,T_0) (t_i,T_0) ... DEM (t_i,T_j) (t_i,T_j) ... DEM (t_i,T_{M-1}) (t_i,T_{M-1}) ... ... ... ... ... DEM (t_{N-1},T_0) (t_{N-1},T_0) ... DEM (t_{N-1},T_j) (t_{N-1},T_j) ... DEM (t_{N-1},T_{M-1}) (t_{N-1},T_{M-1}) where M M is the number of temperature bins and N N is again the number of timesteps.","title":"Configuration"},{"location":"configuration/#heating","text":"The time dependent heating is configured in a separate node. It includes the following parameters, Parameter Type Description partition float partition of heating between electrons and ions, between 0 and 1; 1 is pure electron heating, 0 pure ion heating background float constant background heating (in ergs cm ^{-3} ^{-3} s ^{-1} ^{-1} ) The heating function is constructed by a list of discrete events and should be specified in the following way, <events> <event magnitude= \"0.1\" rise_start= \"0.0\" rise_end= \"50.0\" decay_start= \"50.0\" decay_end= \"100.0\" /> <event magnitude= \"0.05\" rise_start= \"1000.0\" rise_end= \"1250.0\" decay_start= \"1350.0\" decay_end= \"1450.0\" /> </events> Here, we've configured two separate heating events. The first starts at 0 seconds, rises linearly to a maximum heating rate of 0.1 erg cm ^{-3} ^{-3} s ^{-1} ^{-1} in 50 seconds, and then immediately falls off with the event concluding at 100 seconds, i.e. a triangular heating profile. The second starts at 1000 seconds, rises to a maximum heating rate of 0.05 erg cm ^{-3} ^{-3} s ^{-1} ^{-1} in 250 seconds, is sustained at 0.05 for 100 seconds and then the event concludes at 1450 seconds. Using this format, it is easy to specify either symmetric or asymmetric events of many different shapes. For more examples, see the example configuration file or the included examples .","title":"Heating"},{"location":"configuration/#differential-emission-measure","text":"Optionally, ebtel++ can can also calculate the differential emission measure (DEM) in both the transition region and the corona. See sections 2.2 and 3 of Klimchuk et al. (2008) for the details of this calculation. To enable this calculation, set calculate_dem to True in the configuration file (as described above). Note that this will result in much longer computation times. If calculate_dem is set to True , ebtel++ will read in the dem node from the configuration file which should be structured as follows, <dem> <use_new_method> True </use_new_method> <temperature bins= \"451\" log_min= \"4\" log_max= \"8.5\" /> </dem> If use_new_method is set to True (False), the transition region DEM is calculated using the method outlined in section 3 (the appendix) of Klimchuk et al. (2008) . The temperature node configures the range and number of bins used when calculating the DEM. Here, for example, there are 450 bins of equal width between 10^4 10^4 and 10^{8.5} 10^{8.5} K. If you do not need to calculate the DEM, set the calculate_dem parameter to False and this section of the configuration file need not be included.","title":"Differential Emission Measure"},{"location":"configuration/#output","text":"Once the EBTEL run has finished, the results are printed to the file specified in output_filename in the configuration file (as described above). Several examples of how to parse the results in Python can be found here . In general, the results file follows the structure, t_0 t_0 T_e(t_0) T_e(t_0) T_i(t_0) T_i(t_0) n(t_0) n(t_0) p_e(t_0) p_e(t_0) p_i(t_0) p_i(t_0) v(t_0) v(t_0) h(t_0) h(t_0) ... ... ... ... ... ... ... ... t_i t_i T_e(t_i) T_e(t_i) T_i(t_i) T_i(t_i) n(t_i) n(t_i) p_e(t_i) p_e(t_i) p_i(t_i) p_i(t_i) v(t_i) v(t_i) h(t_i) h(t_i) ... ... ... ... ... ... ... ... t_{N-1} t_{N-1} T_e(t_{N-1}) T_e(t_{N-1}) T_i(t_{N-1}) T_i(t_{N-1}) n(t_{N-1}) n(t_{N-1}) p_e(t_{N-1}) p_e(t_{N-1}) p_i(t_{N-1}) p_i(t_{N-1}) v(t_{N-1}) v(t_{N-1}) h(t_{N-1}) h(t_{N-1}) Here t t is the time, T_e T_e is the electron temperature, T_i T_i is the ion temperature, p_e p_e is the electron pressure, p_i p_i is the ion pressure, n n is the density, v v is the velocity, and h h is the heating rate. If calculate_dem is set to True, the TR and coronal DEM results are printed to <output_filename>.dem_tr and <output_filename>.dem_corona , respectively. These output files are structured in the following way, T_0 T_0 ... T_j T_j ... T_{M-1} T_{M-1} DEM (t_0,T_0) (t_0,T_0) ... DEM (t_0,T_j) (t_0,T_j) ... DEM (t_0,T_{M-1}) (t_0,T_{M-1}) ... ... ... ... ... DEM (t_i,T_0) (t_i,T_0) ... DEM (t_i,T_j) (t_i,T_j) ... DEM (t_i,T_{M-1}) (t_i,T_{M-1}) ... ... ... ... ... DEM (t_{N-1},T_0) (t_{N-1},T_0) ... DEM (t_{N-1},T_j) (t_{N-1},T_j) ... DEM (t_{N-1},T_{M-1}) (t_{N-1},T_{M-1}) where M M is the number of temperature bins and N N is again the number of timesteps.","title":"Output"},{"location":"examples/","text":"Included below are a few examples of how to run ebtel++ and plot the results using Python. The results files can be parsed very easily by any language (e.g. IDL,Matlab). Configuration files can also be easily manipulated by hand, but in practice, particularly when computing many EBTEL runs, it is better to script this. The util.py script provides several convenient utilities for manipulating these configuration files. Electron Heating In this example, only the electrons are heated by a single triangular pulse lasting 500 seconds and injecting 10 ergs per cubic centimeter into the loop plasma. The code used to make this figure can be found here . Ion Heating In this second example, only the ions are heated. In this case, we heat the ions with five distinct pulses, each lasting 200 seconds and separated by about 2000 seconds. The energies are uniformly distributed between 0.001 and 0.1 ergs per cubic centimeter per second. The example code can be found here . Note how easy it is to programmatically generate the configurations for these different heating profiles. Single Fluid Lastly, we show an example where the electron and ion populations are forced into equilibrium at all times, i.e. the single-fluid case. The loop plasma is heated by a single pulse lasting 2000 seconds that rises quickly (in 250 seconds), is sustained at 0.005 ergs per cubic centimeter per second for 750 seconds, and then decays back to the background value over 1000 seconds. The example code can be found here .","title":"Examples"},{"location":"examples/#electron-heating","text":"In this example, only the electrons are heated by a single triangular pulse lasting 500 seconds and injecting 10 ergs per cubic centimeter into the loop plasma. The code used to make this figure can be found here .","title":"Electron Heating"},{"location":"examples/#ion-heating","text":"In this second example, only the ions are heated. In this case, we heat the ions with five distinct pulses, each lasting 200 seconds and separated by about 2000 seconds. The energies are uniformly distributed between 0.001 and 0.1 ergs per cubic centimeter per second. The example code can be found here . Note how easy it is to programmatically generate the configurations for these different heating profiles.","title":"Ion Heating"},{"location":"examples/#single-fluid","text":"Lastly, we show an example where the electron and ion populations are forced into equilibrium at all times, i.e. the single-fluid case. The loop plasma is heated by a single pulse lasting 2000 seconds that rises quickly (in 250 seconds), is sustained at 0.005 ergs per cubic centimeter per second for 750 seconds, and then decays back to the background value over 1000 seconds. The example code can be found here .","title":"Single Fluid"},{"location":"api/classes/","text":"class Dem Class for holding all of the methods needed to calculate the differential emission measure in the transition region and the corona. Requires the loop object for knowledge about the evolution of the coronal loop. Fields Name Type Description loop LOOP Loop object use_new_method bool Method option for DEM TR calculation __temperature std::vector Temperature range __radiative_loss std::vector Radiative loss dem_TR std::vector Transition region DEM dem_corona std::vector Coronal DEM Constructors Dem () Used when we don't want to actually do the DEM calculation. Just a placeholder. Dem ( LOOP loop) Setup Dem object to calculate differential emission measure in both the transition region and the corona. loop Loop object that provides needed parameters and methods Destructors ~Dem () Methods void CalculateDEM ( int i) Front end for DEM calculations. Calls methods to calculate both the transition region and coronal DEM across the entire specified temperature range. i Timestep index void PrintToFile ( int num_steps) Print coronal and transition region DEM arrays to separate files. The filenames are the output filename as given in Dem::loop, suffixed by .dem_corona and .dem_tr , respectively. The first row of each file is the temperature vector, Dem::__temperature. num_steps number of steps taken by the integration routine class Heater Class for configuring time-dependent heating profiles. Accepts a properly formatted XML node and calculates the heating rate at any time. Heating profiles must be specified in terms of num_events heating pulses plus a static background background. You can also initialize a blank object and set the event parameters later on. Fields Name Type Description background double Background heating rate (in erg cm^-3 s^-1) num_events int Number of events time_start_rise std::vector Starting time of the rise phase (in s) time_end_rise std::vector Ending time of the rise phase (in s) time_start_decay std::vector Starting time of the decay phase (in s) time_end_decay std::vector Ending time of the decay phase (in s) magnitude std::vector Magnitudes of the events (in erg cm^-3 s^-1) partition double Partition of energy between electrons and ions; 1 corresponds to pure electron heating and 0 pure ion heating. For a single-fluid treatment, use 0.5 Constructors Heater ( tinyxml2::XMLElement heating_node) heating_node XML node holding the heating information Heater () Destructors ~Heater () Methods double Get_Heating ( double time) Given the heating profile specified by the configuration file, return the heating rate at the given time time time current time (in s) class Loop Class for holding all of the information about the loop. It can be passed a configuration and after the initial conditions are set up, it is evolved through time. Variables Name Type Description heater HEATER Instance of the Heater object parameters Parameters Parameter structure terms Terms Terms structure Constructors Loop ( char config) Setup the loop object by reading in parameters from the configuration file <ebtel_config> into the Loop::parameters structure. The constructor also creates the Loop::heater object for calculating the heating profile. config main configuration file Loop () Create object without any configuration. Useful if parameters are going to be read in from memory rather than from a configuration file. Destructors ~Loop () Methods double CalculateC1 ( double temperature_e, double temperature_i, double density) Calculate the c_1 c_1 parameter, the ratio between the transition and coronal radiative losses temperature_e electron temperature (in K) temperature_i ion temperature (in K) density number density (in cm ^{-3} ^{-3} ) double CalculateC2 () Calculate the ratio of the average to apex temperature. Fixed at 0.9 for now. double CalculateC3 () Calculate the ratio of the base (corona/interface point)to apex temperature. Fixed at 0.6 for now. void CalculateDerivs ( state_type state, state_type derivs, double time) Calculate the rate of change of the electron pressure, ion pressure, and density according to the two-fluid EBTEL equations. A full derivation of these equations can be found in Appendix B of Barnes et al. (2016) . state current state of the loop derivs time current time (in s) state_type CalculateInitialConditions () Calculate the equilibrium values of pressure, temperature, and density based on the supplied loop half-length and initial heating according to the equilibrium solutions of the EBTEL equations. double CalculateRadiativeLoss ( double temperature) Calculate the radiative loss at a particular temperature using the power-law approximation. The formulation used here is based on the calculations of John Raymond (1994, private communication) and twice the coronal abundances of Meyer (1985). This is the same power-law radiative loss function as is implemented in the HYDRAD code and the EBTEL IDL code. temperature electron temperature (in K) double CalculateScaleHeight ( double temperature_e, double temperature_i) Calculate the temperature scale height of the loop. This parameter is used when accounting for gravitational stratification in the model. temperature_e electron temperature (in K) temperature_i ion temperature (in K) double CalculateThermalConduction ( double temperature, double density, std::string species) Calculate the heat flux for either the electrons or ions, depending on the value of species. The classical Spitzer formula is used. If <Parameters.use_flux_limiting> is set to true in the configuration file, then a flux limiter is used to prevent runaway cooling. temperature temperature (in K) density density (in cm ^{-3} ^{-3} ) species either \"electron\" or \"ion\" double CalculateVelocity ( double temperature_e, double temperature_i, double pressure_e) Calculate the velocity using the base electron pressure and the enthalpy flux as determined by our EBTEL equations. temperature_e electron temperature (in K) temperature_i ion temperature (in K) pressure_e electron pressure (in dyne cm ^{-2} ^{-2} s ^{-1} ^{-1} ) state_type GetState () void PrintToFile ( int num_steps) Print results of EBTEL simulation to filename supplied in configuration file. See documentation for the structure of the file itself and instructions on how to parse it. num_steps number of steps taken by the integration routine void SaveResults ( int i, double time) i Current timestep time Current time (in s) void SaveTerms () void SetState ( state_type state) state electron pressure, ion pressure, and density to set as the current loop state void Setup () Allocate space for results and set some parameters. If you create the object with the empty constructor, you need to call this later on. If you use the default config file approach, this is called automatically. class Observer The Observer watches the integrator routine and is called at every timestep to do something. Here, the observer updates the state and saves any necessary results. Constructors Observer ( LOOP loop, DEM dem) Class for monitoring the integration routine. This object includes methods for watching the integration and saving any needed parameters at each timestep. loop Loop instance used for saving loop results dem Dem instance used for saving emission measure results Destructors ~Observer () Methods int CheckNan ( state_type state, double time, double tau, double old_time, double old_tau) Boost integrator does not check for NaNs so this is done manually. If a NaN is found anywhere in the state vector, the state and time are set back to the previous step and the timestep is reduced. state current state of the loop system time current time tau current timestep old_time previous time old_tau previous timestep void Observe ( state_type state, double time) Method called at each step in the integration. It calls methods from Loop and Dem to save relevant results. state current state of the loop system time current time","title":"Classes"},{"location":"api/classes/#class-dem","text":"Class for holding all of the methods needed to calculate the differential emission measure in the transition region and the corona. Requires the loop object for knowledge about the evolution of the coronal loop.","title":"class Dem"},{"location":"api/classes/#fields","text":"Name Type Description loop LOOP Loop object use_new_method bool Method option for DEM TR calculation __temperature std::vector Temperature range __radiative_loss std::vector Radiative loss dem_TR std::vector Transition region DEM dem_corona std::vector Coronal DEM","title":"Fields"},{"location":"api/classes/#constructors","text":"","title":"Constructors"},{"location":"api/classes/#dem","text":"Used when we don't want to actually do the DEM calculation. Just a placeholder.","title":"Dem ()"},{"location":"api/classes/#dem-loop-loop","text":"Setup Dem object to calculate differential emission measure in both the transition region and the corona. loop Loop object that provides needed parameters and methods","title":"Dem (LOOP loop)"},{"location":"api/classes/#destructors","text":"","title":"Destructors"},{"location":"api/classes/#dem_1","text":"","title":"~Dem ()"},{"location":"api/classes/#methods","text":"","title":"Methods"},{"location":"api/classes/#void-calculatedem-int-i","text":"Front end for DEM calculations. Calls methods to calculate both the transition region and coronal DEM across the entire specified temperature range. i Timestep index","title":"void CalculateDEM (int i)"},{"location":"api/classes/#void-printtofile-int-num_steps","text":"Print coronal and transition region DEM arrays to separate files. The filenames are the output filename as given in Dem::loop, suffixed by .dem_corona and .dem_tr , respectively. The first row of each file is the temperature vector, Dem::__temperature. num_steps number of steps taken by the integration routine","title":"void PrintToFile (int num_steps)"},{"location":"api/classes/#class-heater","text":"Class for configuring time-dependent heating profiles. Accepts a properly formatted XML node and calculates the heating rate at any time. Heating profiles must be specified in terms of num_events heating pulses plus a static background background. You can also initialize a blank object and set the event parameters later on.","title":"class Heater"},{"location":"api/classes/#fields_1","text":"Name Type Description background double Background heating rate (in erg cm^-3 s^-1) num_events int Number of events time_start_rise std::vector Starting time of the rise phase (in s) time_end_rise std::vector Ending time of the rise phase (in s) time_start_decay std::vector Starting time of the decay phase (in s) time_end_decay std::vector Ending time of the decay phase (in s) magnitude std::vector Magnitudes of the events (in erg cm^-3 s^-1) partition double Partition of energy between electrons and ions; 1 corresponds to pure electron heating and 0 pure ion heating. For a single-fluid treatment, use 0.5","title":"Fields"},{"location":"api/classes/#constructors_1","text":"","title":"Constructors"},{"location":"api/classes/#heater-tinyxml2xmlelement-heating_node","text":"heating_node XML node holding the heating information","title":"Heater (tinyxml2::XMLElement heating_node)"},{"location":"api/classes/#heater","text":"","title":"Heater ()"},{"location":"api/classes/#destructors_1","text":"","title":"Destructors"},{"location":"api/classes/#heater_1","text":"","title":"~Heater ()"},{"location":"api/classes/#methods_1","text":"","title":"Methods"},{"location":"api/classes/#double-get_heating-double-time","text":"Given the heating profile specified by the configuration file, return the heating rate at the given time time time current time (in s)","title":"double Get_Heating (double time)"},{"location":"api/classes/#class-loop","text":"Class for holding all of the information about the loop. It can be passed a configuration and after the initial conditions are set up, it is evolved through time.","title":"class Loop"},{"location":"api/classes/#variables","text":"Name Type Description heater HEATER Instance of the Heater object parameters Parameters Parameter structure terms Terms Terms structure","title":"Variables"},{"location":"api/classes/#constructors_2","text":"","title":"Constructors"},{"location":"api/classes/#loop-char-config","text":"Setup the loop object by reading in parameters from the configuration file <ebtel_config> into the Loop::parameters structure. The constructor also creates the Loop::heater object for calculating the heating profile. config main configuration file","title":"Loop (char config)"},{"location":"api/classes/#loop","text":"Create object without any configuration. Useful if parameters are going to be read in from memory rather than from a configuration file.","title":"Loop ()"},{"location":"api/classes/#destructors_2","text":"","title":"Destructors"},{"location":"api/classes/#loop_1","text":"","title":"~Loop ()"},{"location":"api/classes/#methods_2","text":"","title":"Methods"},{"location":"api/classes/#double-calculatec1-double-temperature_e-double-temperature_i-double-density","text":"Calculate the c_1 c_1 parameter, the ratio between the transition and coronal radiative losses temperature_e electron temperature (in K) temperature_i ion temperature (in K) density number density (in cm ^{-3} ^{-3} )","title":"double CalculateC1 (double temperature_e, double temperature_i, double density)"},{"location":"api/classes/#double-calculatec2","text":"Calculate the ratio of the average to apex temperature. Fixed at 0.9 for now.","title":"double CalculateC2 ()"},{"location":"api/classes/#double-calculatec3","text":"Calculate the ratio of the base (corona/interface point)to apex temperature. Fixed at 0.6 for now.","title":"double CalculateC3 ()"},{"location":"api/classes/#void-calculatederivs-state_type-state-state_type-derivs-double-time","text":"Calculate the rate of change of the electron pressure, ion pressure, and density according to the two-fluid EBTEL equations. A full derivation of these equations can be found in Appendix B of Barnes et al. (2016) . state current state of the loop derivs time current time (in s)","title":"void CalculateDerivs (state_type state, state_type derivs, double time)"},{"location":"api/classes/#state_type-calculateinitialconditions","text":"Calculate the equilibrium values of pressure, temperature, and density based on the supplied loop half-length and initial heating according to the equilibrium solutions of the EBTEL equations.","title":"state_type CalculateInitialConditions ()"},{"location":"api/classes/#double-calculateradiativeloss-double-temperature","text":"Calculate the radiative loss at a particular temperature using the power-law approximation. The formulation used here is based on the calculations of John Raymond (1994, private communication) and twice the coronal abundances of Meyer (1985). This is the same power-law radiative loss function as is implemented in the HYDRAD code and the EBTEL IDL code. temperature electron temperature (in K)","title":"double CalculateRadiativeLoss (double temperature)"},{"location":"api/classes/#double-calculatescaleheight-double-temperature_e-double-temperature_i","text":"Calculate the temperature scale height of the loop. This parameter is used when accounting for gravitational stratification in the model. temperature_e electron temperature (in K) temperature_i ion temperature (in K)","title":"double CalculateScaleHeight (double temperature_e, double temperature_i)"},{"location":"api/classes/#double-calculatethermalconduction-double-temperature-double-density-stdstring-species","text":"Calculate the heat flux for either the electrons or ions, depending on the value of species. The classical Spitzer formula is used. If <Parameters.use_flux_limiting> is set to true in the configuration file, then a flux limiter is used to prevent runaway cooling. temperature temperature (in K) density density (in cm ^{-3} ^{-3} ) species either \"electron\" or \"ion\"","title":"double CalculateThermalConduction (double temperature, double density, std::string species)"},{"location":"api/classes/#double-calculatevelocity-double-temperature_e-double-temperature_i-double-pressure_e","text":"Calculate the velocity using the base electron pressure and the enthalpy flux as determined by our EBTEL equations. temperature_e electron temperature (in K) temperature_i ion temperature (in K) pressure_e electron pressure (in dyne cm ^{-2} ^{-2} s ^{-1} ^{-1} )","title":"double CalculateVelocity (double temperature_e, double temperature_i, double pressure_e)"},{"location":"api/classes/#state_type-getstate","text":"","title":"state_type GetState ()"},{"location":"api/classes/#void-printtofile-int-num_steps_1","text":"Print results of EBTEL simulation to filename supplied in configuration file. See documentation for the structure of the file itself and instructions on how to parse it. num_steps number of steps taken by the integration routine","title":"void PrintToFile (int num_steps)"},{"location":"api/classes/#void-saveresults-int-i-double-time","text":"i Current timestep time Current time (in s)","title":"void SaveResults (int i, double time)"},{"location":"api/classes/#void-saveterms","text":"","title":"void SaveTerms ()"},{"location":"api/classes/#void-setstate-state_type-state","text":"state electron pressure, ion pressure, and density to set as the current loop state","title":"void SetState (state_type state)"},{"location":"api/classes/#void-setup","text":"Allocate space for results and set some parameters. If you create the object with the empty constructor, you need to call this later on. If you use the default config file approach, this is called automatically.","title":"void Setup ()"},{"location":"api/classes/#class-observer","text":"The Observer watches the integrator routine and is called at every timestep to do something. Here, the observer updates the state and saves any necessary results.","title":"class Observer"},{"location":"api/classes/#constructors_3","text":"","title":"Constructors"},{"location":"api/classes/#observer-loop-loop-dem-dem","text":"Class for monitoring the integration routine. This object includes methods for watching the integration and saving any needed parameters at each timestep. loop Loop instance used for saving loop results dem Dem instance used for saving emission measure results","title":"Observer (LOOP loop, DEM dem)"},{"location":"api/classes/#destructors_3","text":"","title":"Destructors"},{"location":"api/classes/#observer","text":"","title":"~Observer ()"},{"location":"api/classes/#methods_3","text":"","title":"Methods"},{"location":"api/classes/#int-checknan-state_type-state-double-time-double-tau-double-old_time-double-old_tau","text":"Boost integrator does not check for NaNs so this is done manually. If a NaN is found anywhere in the state vector, the state and time are set back to the previous step and the timestep is reduced. state current state of the loop system time current time tau current timestep old_time previous time old_tau previous timestep","title":"int CheckNan (state_type state, double time, double tau, double old_time, double old_tau)"},{"location":"api/classes/#void-observe-state_type-state-double-time","text":"Method called at each step in the integration. It calls methods from Loop and Dem to save relevant results. state current state of the loop system time current time","title":"void Observe (state_type state, double time)"},{"location":"api/structs/","text":"struct Parameters Structure to hold all input parameters Fields Name Type Description total_time double Total simulation time (in s) tau double Timestep (in s); when using adaptive solver, the initial timestep tau_max double Maximum allowed timestep (in s) when using adaptive solver loop_length double Loop half length (in cm) adaptive_solver_error double Truncation error tolerance for adaptive solver adaptive_solver_safety double Safety factor on allowed timestep for adaptive solver saturation_limit double Heat flux saturation limit; 1/6 is a typical value c1_cond0 double Nominal conductive c1 value; 6.0 is recommended c1_rad0 double Nominal radiative c1 value; 0.6 is recommended force_single_fluid bool Force collision frequency to 0.9 s^-1 to emulate single-species fluid use_c1_loss_correction bool Switch for radiative loss correction to c1 use_c1_grav_correction bool Switch for gravitational correction to c1 use_flux_limiting bool Switch for classical Spitzer conductivity calculate_dem bool Switch for calculating DEM; if True, runtimes will be much longer save_terms bool Switch for saving extra equation terms use_adaptive_solver bool Switch for using the adaptive solver option output_filename std::string Path to output file dem_options tinyxml2::XMLElement XML node holding DEM calculation parameters boltzmann_correction double Correction to ion equation of state ion_mass_correction double Ion mass correction to account for He abundance helium_to_hydrogen_ratio double Ratio of helium to hydrogen surface_gravity double Gravitational acceleration at stellar surface N size_t Number of grid points struct Results Structure to hold all results Fields Name Type Description time std::vector Time (in s) temperature_e std::vector Electron temperature (in K) temperature_i std::vector Ion temperature (in K) pressure_e std::vector Electron pressure (in dyne cm^-2 s^-1) pressure_i std::vector Ion pressure (in dyne cm^-2 s^-1) density std::vector Number density (in cm^-3) velocity std::vector Velocity (in cm s^-1) heat std::vector Heating rate (in erg cm^-3 s^-1) struct Terms Structure to hold equation terms Fields Name Type Description f_e std::vector Electron heat flux (in erg cm^-2 s^-1) f_i std::vector Ion heat flux (in erg cm^-2 s^-1) radiative_loss std::vector Radiative_loss (in erg cm^3 s^-1) c1 std::vector c1 coefficient","title":"Structs"},{"location":"api/structs/#struct-parameters","text":"Structure to hold all input parameters","title":"struct Parameters"},{"location":"api/structs/#fields","text":"Name Type Description total_time double Total simulation time (in s) tau double Timestep (in s); when using adaptive solver, the initial timestep tau_max double Maximum allowed timestep (in s) when using adaptive solver loop_length double Loop half length (in cm) adaptive_solver_error double Truncation error tolerance for adaptive solver adaptive_solver_safety double Safety factor on allowed timestep for adaptive solver saturation_limit double Heat flux saturation limit; 1/6 is a typical value c1_cond0 double Nominal conductive c1 value; 6.0 is recommended c1_rad0 double Nominal radiative c1 value; 0.6 is recommended force_single_fluid bool Force collision frequency to 0.9 s^-1 to emulate single-species fluid use_c1_loss_correction bool Switch for radiative loss correction to c1 use_c1_grav_correction bool Switch for gravitational correction to c1 use_flux_limiting bool Switch for classical Spitzer conductivity calculate_dem bool Switch for calculating DEM; if True, runtimes will be much longer save_terms bool Switch for saving extra equation terms use_adaptive_solver bool Switch for using the adaptive solver option output_filename std::string Path to output file dem_options tinyxml2::XMLElement XML node holding DEM calculation parameters boltzmann_correction double Correction to ion equation of state ion_mass_correction double Ion mass correction to account for He abundance helium_to_hydrogen_ratio double Ratio of helium to hydrogen surface_gravity double Gravitational acceleration at stellar surface N size_t Number of grid points","title":"Fields"},{"location":"api/structs/#struct-results","text":"Structure to hold all results","title":"struct Results"},{"location":"api/structs/#fields_1","text":"Name Type Description time std::vector Time (in s) temperature_e std::vector Electron temperature (in K) temperature_i std::vector Ion temperature (in K) pressure_e std::vector Electron pressure (in dyne cm^-2 s^-1) pressure_i std::vector Ion pressure (in dyne cm^-2 s^-1) density std::vector Number density (in cm^-3) velocity std::vector Velocity (in cm s^-1) heat std::vector Heating rate (in erg cm^-3 s^-1)","title":"Fields"},{"location":"api/structs/#struct-terms","text":"Structure to hold equation terms","title":"struct Terms"},{"location":"api/structs/#fields_2","text":"Name Type Description f_e std::vector Electron heat flux (in erg cm^-2 s^-1) f_i std::vector Ion heat flux (in erg cm^-2 s^-1) radiative_loss std::vector Radiative_loss (in erg cm^3 s^-1) c1 std::vector c1 coefficient","title":"Fields"},{"location":"api/typedefs/","text":"Name Type Description DEM Dem Pointer to the Dem class HEATER Heater Pointer to the Heater class LOOP Loop Pointer to the Loop class OBSERVER Observer Pointer to the Observer class state_type boost::array Generic type for state vectors and derivatives","title":"Typedefs"}]}